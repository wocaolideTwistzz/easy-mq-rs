pub mod constant;
pub mod scripts;

use deadpool_redis::redis::{self, aio::ConnectionLike};

use crate::{
    errors::{Error, Result},
    rdb::{
        constant::{DEFAULT_WORKER, QName, RedisKey, RedisTaskArgs},
        scripts::{
            CANCEL, CLAIM_DEPENDENT, CLAIM_SCHEDULED, DEPEND, DEQUEUE, ENQUEUE, FAIL, SCHEDULE,
            SUCCEED,
        },
    },
    task::{Task, TaskState},
};

/// -> easy-mq:`qname`:stream
///
/// 将任务直接放入消息队列, 可以直接被`dequeue`消费. 返回任务的stream_id (任务在消息队列中自动生成的自增ID)
///
/// Put the task directly into the message queue, which can be consumed directly by `dequeue`.
/// Returns the task's stream_id (the auto-increment ID automatically generated by the message queue)
pub async fn enqueue(conn: &mut impl ConnectionLike, task: &Task) -> Result<String> {
    debug_assert_eq!(task.runtime.state, TaskState::Pending);

    let qname = QName::from_task(task);
    let task_key = RedisKey::task(&qname, &task.id).to_string();
    let stream_key = RedisKey::stream(&qname).to_string();
    let deadline_key = RedisKey::deadline(&qname).to_string();

    let task_args = RedisTaskArgs::try_from(task)?;

    // 1. 任务入队
    // -> easy-mq:`qname`:stream
    let ret: String = ENQUEUE
        .key(task_key)
        .key(stream_key)
        .key(deadline_key)
        .arg(&task_args)
        .invoke_async(conn)
        .await?;
    if ret == "0" {
        return Err(Error::TaskAlreadyExists);
    }

    // 2. 更新topic时间.
    // Update topic time.
    redis::Cmd::zadd(
        RedisKey::topics().to_string(),
        &task.topic,
        task_args.current,
    )
    .exec_async(conn)
    .await?;

    // 3. 更新topic下的qname
    // Update qname under the topic.
    redis::Cmd::hset(
        RedisKey::qname(&task.topic).to_string(),
        qname.0,
        task_args.current,
    )
    .exec_async(conn)
    .await?;

    Ok(ret)
}

/// -> easy-mq:`qname`:scheduled
///
/// 将任务放入`scheduled`. 会在指定指定的时间到达后再正式进入消息队列.
///
/// Put the task into `scheduled`. It will be officially entered into the message queue after the specified
/// time arrived.
pub async fn schedule(conn: &mut impl ConnectionLike, task: &Task) -> Result<()> {
    debug_assert_eq!(task.runtime.state, TaskState::Scheduled);

    let qname = QName::from_task(task);
    let task_key = RedisKey::task(&qname, &task.id).to_string();
    let scheduled_key = RedisKey::scheduled(&qname).to_string();
    let deadline_key = RedisKey::deadline(&qname).to_string();

    let task_args = RedisTaskArgs::try_from(task)?;

    // 1. 任务入队 scheduled
    // -> easy-mq:`qname`:scheduled
    let ret: i32 = SCHEDULE
        .key(task_key)
        .key(scheduled_key)
        .key(deadline_key)
        .arg(&task_args)
        .invoke_async(conn)
        .await?;
    if ret == 0 {
        return Err(Error::TaskAlreadyExists);
    }

    // 2. 更新topic时间.
    // Update topic time.
    redis::Cmd::zadd(
        RedisKey::topics().to_string(),
        &task.topic,
        task_args.current,
    )
    .exec_async(conn)
    .await?;

    // 3. 更新topic下的qname
    // Update qname under the topic.
    redis::Cmd::hset(
        RedisKey::qname(&task.topic).to_string(),
        qname.0,
        task_args.current,
    )
    .exec_async(conn)
    .await?;

    Ok(())
}

/// -> easy-mq:`qname`:dependent
///
/// 将任务放入`dependent`. 会在指定依赖任务完成后再正式进入消息队列.
///
/// Put the task into `dependent`. It will be officially entered into the message queue after the specified
/// tasks has completed.
pub async fn depend(conn: &mut impl ConnectionLike, task: &Task) -> Result<()> {
    debug_assert_eq!(task.runtime.state, TaskState::Dependent);

    let qname = QName::from_task(task);
    let task_key = RedisKey::task(&qname, &task.id).to_string();
    let dependent_key = RedisKey::dependent(&qname).to_string();
    let dependent_task_key = RedisKey::dependent_task(&qname, &task.id).to_string();
    let deadline_key = RedisKey::deadline(&qname).to_string();

    let task_args = RedisTaskArgs::try_from(task)?;

    // 1. 任务入队 dependent
    // -> easy-mq:`qname`:dependent
    let ret: i32 = DEPEND
        .key(task_key)
        .key(dependent_key)
        .key(dependent_task_key)
        .key(deadline_key)
        .arg(&task_args)
        .invoke_async(conn)
        .await?;
    if ret == 0 {
        return Err(Error::TaskAlreadyExists);
    }

    // 2. 更新topic时间.
    // Update topic time.
    redis::Cmd::zadd(
        RedisKey::topics().to_string(),
        &task.topic,
        task_args.current,
    )
    .exec_async(conn)
    .await?;

    // 3. 更新topic下的qname
    // Update qname under the topic.
    redis::Cmd::hset(
        RedisKey::qname(&task.topic).to_string(),
        qname.0,
        task_args.current,
    )
    .exec_async(conn)
    .await?;

    Ok(())
}

/// <- easy-mq:`qname`:stream ...
///
/// 按顺序从指定的消息队列列表中取出第一个可以被消费的任务.
///
/// Take the first consumable task from the specified message queue list in order.
pub async fn dequeue(
    conn: &mut impl ConnectionLike,
    queues: &[QName],
    worker: Option<&str>,
) -> Result<Option<Task>> {
    let worker = worker.unwrap_or(DEFAULT_WORKER);
    let current = chrono::Local::now().timestamp_millis();

    let task = DEQUEUE
        .key(
            queues
                .iter()
                .map(|qname| RedisKey::stream(qname).to_string())
                .collect::<Vec<_>>(),
        )
        .arg(worker)
        .arg(current)
        .invoke_async(conn)
        .await?;

    Ok(task)
}

/// -> easy-mq:`qname`:archive
///
/// 设置任务状态为成功. 并存档当前任务
///
/// Set the task state to succeed and save it.
pub async fn succeed(
    conn: &mut impl ConnectionLike,
    qname: &QName,
    task_id: &str,
    stream_id: &str,
    result: Option<Vec<u8>>,
) -> Result<()> {
    let task_key = RedisKey::task(qname, task_id).to_string();
    let stream_key = RedisKey::stream(qname).to_string();
    let archive_key = RedisKey::archive(qname).to_string();
    let deadline_key = RedisKey::deadline(qname).to_string();

    let current = chrono::Local::now().timestamp_millis();

    let _: i32 = SUCCEED
        .key(task_key)
        .key(stream_key)
        .key(archive_key)
        .key(deadline_key)
        .arg(stream_id)
        .arg(current)
        .arg(result)
        .invoke_async(conn)
        .await?;
    Ok(())
}

/// -> easy-mq:`qname`:archive
///
/// 设置任务状态为取消. 不会进行重试, 直接存档.
///
/// Set the task state to canceled. It will not be retried; the task will be saved immediately.
pub async fn cancel(
    conn: &mut impl ConnectionLike,
    qname: &QName,
    task_id: &str,
    stream_id: &str,
    err_msg: Option<String>,
) -> Result<()> {
    let task_key = RedisKey::task(qname, task_id).to_string();
    let stream_key = RedisKey::stream(qname).to_string();
    let archive_key = RedisKey::archive(qname).to_string();
    let deadline_key = RedisKey::deadline(qname).to_string();

    let current = chrono::Local::now().timestamp_millis();

    let _: i32 = CANCEL
        .key(task_key)
        .key(stream_key)
        .key(archive_key)
        .key(deadline_key)
        .arg(stream_id)
        .arg(current)
        .arg(err_msg)
        .invoke_async(conn)
        .await?;
    Ok(())
}

/// -> easy-mq:`qname`:archive | easy-mq:`qname`:stream | easy-mq:`qname`:scheduled
///
/// 标记当前任务执行失败或者重试, 会自动根据配置的重试规则自动进行重试或者直接以失败状态存档.
/// 若该任务设置了重试规则, 并且没有重试间隔时间, 将会生成一个新的 stream_id
///
/// Mark the current task as failed/retry/pending. It will automatically retry according to the task option's retry rules
/// or save the task as failed.
/// If the task has a retry rule set and no retry interval is specified, a new stream_id will be generated.
pub async fn fail(
    conn: &mut impl ConnectionLike,
    qname: &QName,
    task_id: &str,
    stream_id: &str,
    err_msg: &str,
) -> Result<Option<String>> {
    let task_key = RedisKey::task(qname, task_id).to_string();
    let stream_key = RedisKey::stream(qname).to_string();
    let scheduled_key = RedisKey::scheduled(qname).to_string();
    let archive_key = RedisKey::archive(qname).to_string();
    let deadline_key = RedisKey::deadline(qname).to_string();

    let current = chrono::Local::now().timestamp_millis();

    let ret: Option<String> = FAIL
        .key(task_key)
        .key(stream_key)
        .key(scheduled_key)
        .key(archive_key)
        .key(deadline_key)
        .arg(stream_id)
        .arg(current)
        .arg(err_msg)
        .invoke_async(conn)
        .await?;
    Ok(ret)
}

pub async fn claim_scheduled(conn: &mut impl ConnectionLike, qname: &QName) -> Result<usize> {
    let scheduled_key = RedisKey::scheduled(qname).to_string();
    let stream_key = RedisKey::stream(qname).to_string();

    let current = chrono::Local::now().timestamp_millis();

    let count = CLAIM_SCHEDULED
        .key(scheduled_key)
        .key(stream_key)
        .arg(current)
        .invoke_async(conn)
        .await?;

    Ok(count)
}

pub async fn claim_dependent(
    conn: &mut impl ConnectionLike,
    qname: &QName,
) -> Result<(usize, usize)> {
    let dependent_key = RedisKey::dependent(qname).to_string();
    let stream_key = RedisKey::stream(qname).to_string();
    let archive_key = RedisKey::archive(qname).to_string();
    let deadline_key = RedisKey::deadline(qname).to_string();

    let current = chrono::Local::now().timestamp_millis();

    let (pending_count, canceled_count) = CLAIM_DEPENDENT
        .key(dependent_key)
        .key(stream_key)
        .key(archive_key)
        .key(deadline_key)
        .arg(current)
        .arg(qname.to_string())
        .invoke_async(conn)
        .await?;

    Ok((pending_count, canceled_count))
}

#[cfg(test)]
mod test {
    use deadpool_redis::{Config, Connection};

    use crate::{
        rdb::{
            cancel, claim_dependent, claim_scheduled, constant::QName, depend, dequeue, enqueue,
            fail, schedule, succeed,
        },
        task::{ScheduledAt, Task, TaskCompletedState},
    };

    async fn new_redis_conn() -> Connection {
        let pool = Config::from_url("redis://127.0.0.1:6379")
            .builder()
            .unwrap()
            .build()
            .unwrap();

        pool.get().await.unwrap()
    }

    #[tokio::test]
    async fn test_enqueue() {
        let task = Task::new("test_topic", None);

        let mut conn = new_redis_conn().await;

        let stream_id = enqueue(&mut conn, &task).await.unwrap();

        println!("{} - {}", task.id, stream_id)
    }

    #[tokio::test]
    async fn test_dequeue() {
        let mut conn = new_redis_conn().await;

        let qname = QName::new("test_topic", 0);
        let task = dequeue(&mut conn, &[qname], None).await.unwrap();

        println!("{:?}", task)
    }

    #[tokio::test]
    async fn test_schedule() {
        let mut conn = new_redis_conn().await;

        let scheduled_at = chrono::Local::now().timestamp_millis() as u64 + 1000 * 5;
        let task =
            Task::new("test_topic", None).with_scheduled(ScheduledAt::TimestampMs(scheduled_at));

        schedule(&mut conn, &task).await.unwrap();
    }

    #[tokio::test]
    async fn test_succeed() {
        let mut conn = new_redis_conn().await;

        let queues = vec![QName::new("test_topic", 0)];
        loop {
            match dequeue(&mut conn, &queues, None).await.unwrap() {
                Some(task) => {
                    println!(
                        "Succeed -> {} - {}",
                        task.id,
                        task.runtime.stream_id.as_ref().unwrap()
                    );
                    succeed(
                        &mut conn,
                        &queues[0],
                        &task.id,
                        task.runtime.stream_id.as_ref().unwrap(),
                        None,
                    )
                    .await
                    .unwrap();
                }
                None => return,
            }
        }
    }

    #[tokio::test]
    async fn test_fail() {
        let mut conn = new_redis_conn().await;

        let queues = vec![QName::new("test_topic", 0)];
        loop {
            match dequeue(&mut conn, &queues, None).await.unwrap() {
                Some(task) => {
                    println!(
                        "Fail -> {} - {}",
                        task.id,
                        task.runtime.stream_id.as_ref().unwrap()
                    );
                    fail(
                        &mut conn,
                        &queues[0],
                        &task.id,
                        task.runtime.stream_id.as_ref().unwrap(),
                        "something wrong",
                    )
                    .await
                    .unwrap();
                }
                None => return,
            }
        }
    }

    #[tokio::test]
    async fn test_cancel() {
        let mut conn = new_redis_conn().await;

        let queues = vec![QName::new("test_topic", 0)];
        loop {
            match dequeue(&mut conn, &queues, None).await.unwrap() {
                Some(task) => {
                    println!(
                        "Cancel -> {} - {}",
                        task.id,
                        task.runtime.stream_id.as_ref().unwrap()
                    );
                    cancel(
                        &mut conn,
                        &queues[0],
                        &task.id,
                        task.runtime.stream_id.as_ref().unwrap(),
                        None,
                    )
                    .await
                    .unwrap();
                }
                None => return,
            }
        }
    }

    #[tokio::test]
    async fn test_dependent() {
        let mut conn = new_redis_conn().await;

        let required_tasks = (0..10)
            .map(|_| Task::new("test_topic", None))
            .collect::<Vec<_>>();

        let dep_task = Task::new("test_topic", None).with_scheduled(ScheduledAt::DependsOn(
            required_tasks
                .iter()
                .map(|v| v.to_completed_task(TaskCompletedState::Any))
                .collect(),
        ));
        let dep_task1 = Task::new("test_topic", None).with_scheduled(ScheduledAt::DependsOn(
            required_tasks
                .iter()
                .map(|v| v.to_completed_task(TaskCompletedState::Succeed))
                .collect(),
        ));

        for task in required_tasks {
            enqueue(&mut conn, &task).await.unwrap();
        }

        depend(&mut conn, &dep_task).await.unwrap();
        depend(&mut conn, &dep_task1).await.unwrap()
    }

    #[tokio::test]
    async fn test_claim_scheduled() {
        let mut conn = new_redis_conn().await;

        let qname = QName::new("test_topic", 0);

        let scheduled_count = claim_scheduled(&mut conn, &qname).await.unwrap();

        println!("scheduled: {scheduled_count}");
    }

    #[tokio::test]
    async fn test_claim_dependent() {
        let mut conn = new_redis_conn().await;

        let (pending_count, canceled_count) =
            claim_dependent(&mut conn, &QName::new("test_topic", 0))
                .await
                .unwrap();

        println!("pending: {pending_count}");
        println!("canceled: {canceled_count}");
    }
}
